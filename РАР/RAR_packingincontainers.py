#Для решения этой задачи можно использовать алгоритм поиска с возвратом (backtracking).


def can_pack(items, K, B):
    # Функция для рекурсивной проверки возможности упаковки
    def can_partition(start, current_bins):
        if start == len(items):
            return True
        
        for i in range(len(current_bins)):
            if current_bins[i] + items[start] <= B:
                current_bins[i] += items[start]
                if can_partition(start + 1, current_bins):
                    return True
                current_bins[i] -= items[start]
                
            if current_bins[i] == 0:  # Пропускаем пустые контейнеры
                break
                
        return False
    
    items.sort(reverse=True)  # Оптимизация: сортируем предметы в порядке убывания

    bin_items = [0] * K  # Начальные величины для K корзин (контейнеров)
    return can_partition(0, bin_items)

# Пример использования
items = [4, 8, 1, 4, 2, 1]
K = 3
B = 10

result = can_pack(items, K, B)
print("Можно сгруппировать" if result else "Нельзя сгруппировать")

#Этот код определяет функцию can_pack, которая проверяет, можно ли разместить все предметы в не более чем K контейнерах, 
#так чтобы суммарный вес предметов в каждом контейнере не превышал B.

#Кратко алгоритм работает следующим образом:

#can_partition — это рекурсивная функция, которая проверяет возможность упаковки предметов.
#Внутри can_partition, мы пробуем добавить текущий предмет в одну из корзин (контейнеров).
#Если суммарный вес в любой корзине превысит B, мы откатываем предыдущее действие и пробуем другую корзину.
#Если мы успешно расположили все предметы, функция возвращает True.
#items.sort(reverse=True) оптимизирует процесс, начиная с самых тяжелых предметов, так как они ограничивают возможности раскладки в контейнеры.